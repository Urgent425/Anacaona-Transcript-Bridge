// Backend/routes/TranscriptRoutes.js
const express = require("express");
const multer = require("multer");
const jwt = require("jsonwebtoken");
const Transcript = require("../models/Transcript");
const pdfParse = require("pdf-parse");

const { buildKey, uploadBuffer } = require("../services/r2Storage");

const router = express.Router();

const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 25 * 1024 * 1024 }, // 25MB each (adjust)
});

function requireStudent(req) {
  const token = req.headers.authorization?.split(" ")[1];
  if (!token) return { error: { code: 401, body: { error: "Unauthorized" } } };
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    return { studentId: decoded.id };
  } catch {
    return { error: { code: 401, body: { error: "Unauthorized" } } };
  }
}

// Your rule: allow adds until completed
function canAddDocuments(finalStatus) {
  const s = String(finalStatus || "").toLowerCase();
  return s !== "completed"; // keep aligned with your schema enum
}

// ─────────────────────────────────────────────
// POST /api/transcripts/submit
// Submit initial transcript package (R2 storage)
// ─────────────────────────────────────────────
router.post("/submit", upload.array("files"), async (req, res) => {
  try {
    const token = req.headers.authorization?.split(" ")[1];
    if (!token) return res.status(401).json({ error: "Unauthorized" });

    const { id: studentId } = jwt.verify(token, process.env.JWT_SECRET);

    const { purpose, translationFlags, sourceLanguages, submissionMethod } = req.body;

    const flags = translationFlags ? JSON.parse(translationFlags) : [];
    const langs = sourceLanguages ? JSON.parse(sourceLanguages) : [];

    if (!req.files || req.files.length === 0) {
      return res.status(400).json({ error: "No files uploaded" });
    }
    if (!submissionMethod) {
      return res.status(400).json({ error: "Missing submissionMethod" });
    }

    // Create transcript first (submissionId generated by model pre-validate)
    const transcript = new Transcript({
      student: studentId,
      submissionMethod,
      purpose,
      documents: [],
    });

    await transcript.save();
    const submissionId = transcript.submissionId; // SUB-YYYYMMDD-xxxx

    const documents = await Promise.all(
      req.files.map(async (file, index) => {
        let pageCount = 1;

        if (file.mimetype === "application/pdf") {
          const pdfData = await pdfParse(file.buffer);
          pageCount = pdfData.numpages || 1;
        }

        // Upload to R2
        const key = buildKey({
          prefix: "evaluation-submissions",
          requestId: submissionId,
          originalName: file.originalname,
        });

        await uploadBuffer({
          key,
          buffer: file.buffer,
          contentType: file.mimetype,
        });

        return {
          filename: file.originalname,
          mimetype: file.mimetype,
          bucket: process.env.R2_BUCKET,
          key,
          needsTranslation: !!flags[index],
          sourceLanguage: langs[index] || null,
          pageCount,
        };
      })
    );

    transcript.documents = documents;
    await transcript.save();

    return res.json({
      message: "Transcripts submitted successfully",
      submissionId,
    });
  } catch (error) {
    console.error("Submission error:", error);
    res.status(500).json({ error: "Server error" });
  }
});

// ─────────────────────────────────────────────
// GET /api/transcripts/mine
// View submissions for current student
// ─────────────────────────────────────────────
router.get("/mine", async (req, res) => {
  try {
    const auth = requireStudent(req);
    if (auth.error) return res.status(auth.error.code).json(auth.error.body);
    const studentId = auth.studentId;

    const submissions = await Transcript.find({ student: studentId })
      .select("-documents.buffer") // keep (legacy)
      .sort({ createdAt: -1 });

    return res.json(submissions);
  } catch (err) {
    console.error(err);
    return res.status(401).json({ error: "Invalid token" });
  }
});

// ─────────────────────────────────────────────
// POST /api/transcripts/add-to-submission/:submissionId
// Add more documents (allowed until finalStatus completed)
// ─────────────────────────────────────────────
router.post("/add-to-submission/:submissionId", upload.array("files"), async (req, res) => {
  try {
    const token = req.headers.authorization?.split(" ")[1];
    if (!token) return res.status(401).json({ error: "Unauthorized" });

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const studentId = decoded.id;

    const submissionId = req.params.submissionId;

    const flags = req.body.translationFlags
      ? JSON.parse(req.body.translationFlags).map((flag) => flag === "yes" || flag === true)
      : [];
    const langs = req.body.sourceLanguages ? JSON.parse(req.body.sourceLanguages) : [];

    const submission = await Transcript.findOne({ submissionId, student: studentId });
    if (!submission) return res.status(404).json({ error: "Submission not found" });

    // ✅ allow adding anytime until completed
    if (String(submission.finalStatus || "").toLowerCase() === "completed") {
      return res.status(403).json({ error: "This submission is completed and cannot accept new documents." });
    }

    if (!req.files || req.files.length === 0) {
      return res.status(400).json({ error: "No files uploaded" });
    }

    const newDocs = await Promise.all(
      req.files.map(async (file, idx) => {
        let pageCount = 1;
        if (file.mimetype === "application/pdf") {
          const pdfData = await pdfParse(file.buffer);
          pageCount = pdfData.numpages || 1;
        }

        const key = buildKey({
          prefix: "evaluation-submissions",
          requestId: submissionId,
          originalName: file.originalname,
        });

        await uploadBuffer({
          key,
          buffer: file.buffer,
          contentType: file.mimetype,
        });

        return {
          filename: file.originalname,
          mimetype: file.mimetype,
          bucket: process.env.R2_BUCKET,
          key,
          needsTranslation: flags[idx] || false,
          sourceLanguage: langs[idx] || null,
          pageCount,
          addedAt: new Date(),
        };
      })
    );

    submission.documents.push(...newDocs);
    await submission.save();

    res.json({ message: "Documents added successfully", updated: submission });
  } catch (err) {
    console.error("Error adding documents:", err);
    res.status(500).json({ error: "Failed to add documents" });
  }
});

// ─────────────────────────────────────────────
// DELETE /api/transcripts/:submissionId/document/:documentIndex
// (keep your existing logic, but note: you may want to also delete the R2 object later)
// ─────────────────────────────────────────────
router.delete("/:submissionId/document/:documentIndex", async (req, res) => {
  try {
    const auth = requireStudent(req);
    if (auth.error) return res.status(auth.error.code).json(auth.error.body);
    const studentId = auth.studentId;

    const { submissionId } = req.params;
    const documentIndex = Number(req.params.documentIndex);

    const submission = await Transcript.findOne({ submissionId, student: studentId });
    if (!submission) return res.status(404).json({ error: "Submission not found" });

    if (!Array.isArray(submission.documents) ||
        Number.isNaN(documentIndex) ||
        documentIndex < 0 ||
        documentIndex >= submission.documents.length) {
      return res.status(400).json({ error: "Invalid document index" });
    }

    const doc = submission.documents[documentIndex];
    if (doc?.translationPaid === true) {
      return res.status(403).json({
        error: "This document’s translation has already been paid and it cannot be deleted.",
      });
    }

    submission.documents.splice(documentIndex, 1);

    if (submission.documents.length === 0) {
      await Transcript.deleteOne({ _id: submission._id });
      return res.json({
        message: "Document removed, submission deleted as it had no remaining documents.",
      });
    }

    await submission.save();
    return res.json({ message: "Document removed successfully." });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: "Failed to delete document." });
  }
});

module.exports = router;
